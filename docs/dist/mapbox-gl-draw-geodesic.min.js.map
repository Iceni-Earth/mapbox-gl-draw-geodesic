{"version":3,"file":"mapbox-gl-draw-geodesic.min.js","sources":["../node_modules/@mapbox/mapbox-gl-draw/src/constants.js","../src/constants.js","../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/hat/index.js","../src/utils/circle_geojson.js","../node_modules/arc/arc.js","../src/utils/create_geodesic_line.js","../src/utils/create_geodesic_midpoint.js","../node_modules/circle-to-polygon/index.js","../src/utils/create_geodesic_circle.js","../src/utils/create_geodesic_geojson.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","../src/modes/draw_line_string_geodesic.js","../src/modes/draw_polygon_geodesic.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","../node_modules/haversine-js/index.js","../src/utils/distance.js","../src/utils/drag_pan.js","../src/modes/draw_circle_geodesic.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","../src/modes/draw_point_geodesic.js","../src/modes/simple_select_geodesic.js","../src/modes/direct_select_geodesic.js","../src/modes/static_geodesic.js","../src/modes/index.js"],"sourcesContent":["export const classes = {\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select',\n  STATIC: 'static'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","export const modes = {\n    DRAW_CIRCLE: 'draw_circle'\n};\n\nexport const properties = {\n    CIRCLE_RADIUS: 'circleRadius'\n};","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","var hat = module.exports = function (bits, base) {\n    if (!base) base = 16;\n    if (bits === undefined) bits = 128;\n    if (bits <= 0) return '0';\n    \n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    for (var i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n    \n    var rem = digits - Math.floor(digits);\n    \n    var res = '';\n    \n    for (var i = 0; i < Math.floor(digits); i++) {\n        var x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n    \n    if (rem) {\n        var b = Math.pow(base, rem);\n        var x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n    \n    var parsed = parseInt(res, base);\n    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n        return hat(bits, base)\n    }\n    else return res;\n};\n\nhat.rack = function (bits, base, expandBy) {\n    var fn = function (data) {\n        var iters = 0;\n        do {\n            if (iters ++ > 10) {\n                if (expandBy) bits += expandBy;\n                else throw new Error('too many ID collisions, use more bits')\n            }\n            \n            var id = hat(bits, base);\n        } while (Object.hasOwnProperty.call(hats, id));\n        \n        hats[id] = data;\n        return id;\n    };\n    var hats = fn.hats = {};\n    \n    fn.get = function (id) {\n        return fn.hats[id];\n    };\n    \n    fn.set = function (id, value) {\n        fn.hats[id] = value;\n        return fn;\n    };\n    \n    fn.bits = bits || 128;\n    fn.base = base || 16;\n    return fn;\n};\n","import * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport hat from 'hat';\nimport * as ConstantsGeodesic from '../constants';\n\nexport function createCircle(center, radius, properties = {}) {\n  if (!(radius > 0)) {\n    throw new Error('Radius has to be greater then 0');\n  }\n\n  return {\n    id: hat(),\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      [ConstantsGeodesic.properties.CIRCLE_RADIUS]: radius, // km\n      ...properties\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[center, center, center, center, center]] // four handles (NSEW)\n    }\n  };\n}\n\nexport function isCircle(geojson) {\n  return geojson.geometry.type === Constants.geojsonTypes.POLYGON &&\n    typeof geojson.properties[ConstantsGeodesic.properties.CIRCLE_RADIUS] === 'number' &&\n    geojson.properties[ConstantsGeodesic.properties.CIRCLE_RADIUS] > 0;\n}\n\nexport function getCircleCenter(geojson) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  return geojson.geometry.coordinates[0][0];\n}\n\nexport function setCircleCenter(geojson, center) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  geojson.geometry.coordinates = [[center, center, center, center, center]]; // four handles (NSEW)\n}\n\nexport function getCircleRadius(geojson) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  return geojson.properties[ConstantsGeodesic.properties.CIRCLE_RADIUS];\n}\n\nexport function setCircleRadius(geojson, radius) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  geojson.properties[ConstantsGeodesic.properties.CIRCLE_RADIUS] = radius;\n}","'use strict';\n\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function(lon,lat) {\n    this.lon = lon;\n    this.lat = lat;\n    this.x = D2R * lon;\n    this.y = D2R * lat;\n};\n\nCoord.prototype.view = function() {\n    return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function() {\n    var anti_lat = -1 * this.lat;\n    var anti_lon = (this.lon < 0) ? 180 + this.lon : (180 - this.lon) * -1;\n    return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function() {\n    this.coords = [];\n    this.length = 0;\n};\n\nLineString.prototype.move_to = function(coord) {\n    this.length++;\n    this.coords.push(coord);\n};\n\nvar Arc = function(properties) {\n    this.properties = properties || {};\n    this.geometries = [];\n};\n\nArc.prototype.json = function() {\n    if (this.geometries.length <= 0) {\n        return {'geometry': { 'type': 'LineString', 'coordinates': null },\n                'type': 'Feature', 'properties': this.properties\n               };\n    } else if (this.geometries.length == 1) {\n        return {'geometry': { 'type': 'LineString', 'coordinates': this.geometries[0].coords },\n                'type': 'Feature', 'properties': this.properties\n               };\n    } else {\n        var multiline = [];\n        for (var i = 0; i < this.geometries.length; i++) {\n            multiline.push(this.geometries[i].coords);\n        }\n        return {'geometry': { 'type': 'MultiLineString', 'coordinates': multiline },\n                'type': 'Feature', 'properties': this.properties\n               };\n    }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function() {\n    var wkt_string = '';\n    var wkt = 'LINESTRING(';\n    var collect = function(c) { wkt += c[0] + ' ' + c[1] + ','; };\n    for (var i = 0; i < this.geometries.length; i++) {\n        if (this.geometries[i].coords.length === 0) {\n            return 'LINESTRING(empty)';\n        } else {\n            var coords = this.geometries[i].coords;\n            coords.forEach(collect);\n            wkt_string += wkt.substring(0, wkt.length - 1) + ')';\n        }\n    }\n    return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function(start,end,properties) {\n    if (!start || start.x === undefined || start.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    if (!end || end.x === undefined || end.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    this.start = new Coord(start.x,start.y);\n    this.end = new Coord(end.x,end.y);\n    this.properties = properties || {};\n\n    var w = this.start.x - this.end.x;\n    var h = this.start.y - this.end.y;\n    var z = Math.pow(Math.sin(h / 2.0), 2) +\n                Math.cos(this.start.y) *\n                   Math.cos(this.end.y) *\n                     Math.pow(Math.sin(w / 2.0), 2);\n    this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n    if (this.g == Math.PI) {\n        throw new Error('it appears ' + start.view() + ' and ' + end.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n    } else if (isNaN(this.g)) {\n        throw new Error('could not calculate great circle between ' + start + ' and ' + end);\n    }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function(f) {\n    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n    var B = Math.sin(f * this.g) / Math.sin(this.g);\n    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);\n    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);\n    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n    var lon = R2D * Math.atan2(y, x);\n    return [lon, lat];\n};\n\n\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function(npoints,options) {\n    var first_pass = [];\n    if (!npoints || npoints <= 2) {\n        first_pass.push([this.start.lon, this.start.lat]);\n        first_pass.push([this.end.lon, this.end.lat]);\n    } else {\n        var delta = 1.0 / (npoints - 1);\n        for (var i = 0; i < npoints; ++i) {\n            var step = delta * i;\n            var pair = this.interpolate(step);\n            first_pass.push(pair);\n        }\n    }\n    /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n\n      TODO - does not handle all wrapping scenarios yet\n    */\n    var bHasBigDiff = false;\n    var dfMaxSmallDiffLong = 0;\n    // from http://www.gdal.org/ogr2ogr.html\n    // -datelineoffset:\n    // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n    var dfDateLineOffset = options && options.offset ? options.offset : 10;\n    var dfLeftBorderX = 180 - dfDateLineOffset;\n    var dfRightBorderX = -180 + dfDateLineOffset;\n    var dfDiffSpace = 360 - dfDateLineOffset;\n\n    // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n    for (var j = 1; j < first_pass.length; ++j) {\n        var dfPrevX = first_pass[j-1][0];\n        var dfX = first_pass[j][0];\n        var dfDiffLong = Math.abs(dfX - dfPrevX);\n        if (dfDiffLong > dfDiffSpace &&\n            ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) || (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))) {\n            bHasBigDiff = true;\n        } else if (dfDiffLong > dfMaxSmallDiffLong) {\n            dfMaxSmallDiffLong = dfDiffLong;\n        }\n    }\n\n    var poMulti = [];\n    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n        var poNewLS = [];\n        poMulti.push(poNewLS);\n        for (var k = 0; k < first_pass.length; ++k) {\n            var dfX0 = parseFloat(first_pass[k][0]);\n            if (k > 0 &&  Math.abs(dfX0 - first_pass[k-1][0]) > dfDiffSpace) {\n                var dfX1 = parseFloat(first_pass[k-1][0]);\n                var dfY1 = parseFloat(first_pass[k-1][1]);\n                var dfX2 = parseFloat(first_pass[k][0]);\n                var dfY2 = parseFloat(first_pass[k][1]);\n                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 == 180 &&\n                    k+1 < first_pass.length &&\n                   first_pass[k-1][0] > -180 && first_pass[k-1][0] < dfRightBorderX)\n                {\n                     poNewLS.push([-180, first_pass[k][1]]);\n                     k++;\n                     poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                     continue;\n                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 == -180 &&\n                     k+1 < first_pass.length &&\n                     first_pass[k-1][0] > dfLeftBorderX && first_pass[k-1][0] < 180)\n                {\n                     poNewLS.push([180, first_pass[k][1]]);\n                     k++;\n                     poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                     continue;\n                }\n\n                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX)\n                {\n                    // swap dfX1, dfX2\n                    var tmpX = dfX1;\n                    dfX1 = dfX2;\n                    dfX2 = tmpX;\n                    // swap dfY1, dfY2\n                    var tmpY = dfY1;\n                    dfY1 = dfY2;\n                    dfY2 = tmpY;\n                }\n                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n                    dfX2 += 360;\n                }\n\n                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2)\n                {\n                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n                    poNewLS.push([first_pass[k-1][0] > dfLeftBorderX ? 180 : -180, dfY]);\n                    poNewLS = [];\n                    poNewLS.push([first_pass[k-1][0] > dfLeftBorderX ? -180 : 180, dfY]);\n                    poMulti.push(poNewLS);\n                }\n                else\n                {\n                    poNewLS = [];\n                    poMulti.push(poNewLS);\n                }\n                poNewLS.push([dfX0, first_pass[k][1]]);\n            } else {\n                poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n            }\n        }\n    } else {\n        // add normally\n        var poNewLS0 = [];\n        poMulti.push(poNewLS0);\n        for (var l = 0; l < first_pass.length; ++l) {\n            poNewLS0.push([first_pass[l][0],first_pass[l][1]]);\n        }\n    }\n\n    var arc = new Arc(this.properties);\n    for (var m = 0; m < poMulti.length; ++m) {\n        var line = new LineString();\n        arc.geometries.push(line);\n        var points = poMulti[m];\n        for (var j0 = 0; j0 < points.length; ++j0) {\n            line.move_to(points[j0]);\n        }\n    }\n    return arc;\n};\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n  // nodejs\n  module.exports.Coord = Coord;\n  module.exports.Arc = Arc;\n  module.exports.GreatCircle = GreatCircle;\n\n} else {\n  // browser\n  var arc = {};\n  arc.Coord = Coord;\n  arc.Arc = Arc;\n  arc.GreatCircle = GreatCircle;\n}\n","import * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport arc from 'arc';\n\nfunction coordinatesEqual(x, y) {\n  return x[0] === y[0] && x[1] === y[1];\n}\n\nfunction coordinatePairs(array) {\n  return array.slice(0, -1)\n    .map((value, index) => [value, array[index + 1]])\n    .filter(pair => !coordinatesEqual(pair[0], pair[1]));\n}\n  \nfunction createGeodesicLine(coordinates, steps = 32) {\n  const segments = coordinatePairs(coordinates);\n\n  const geodesicSegments = segments.map(segment => {\n    const greatCircle = new arc.GreatCircle(\n      { x: segment[0][0], y: segment[0][1] },\n      { x: segment[1][0], y: segment[1][1] }\n    );\n    return greatCircle.Arc(steps, { offset: 90 }).json();\n  });\n\n  // arc.js returns the line crossing antimeridian split into two MultiLineString segments\n  // (the first going towards to antimeridian, the second going away from antimeridian, both in range -180..180 longitude)\n  // fix Mapbox rendering by merging them together, adding 360 to longitudes on the right side\n  let crossed = false;\n  const geodesicCoordinates = geodesicSegments.map(geodesicSegment => {\n    if (geodesicSegment.geometry.type === Constants.geojsonTypes.MULTI_LINE_STRING) {\n      crossed = !crossed;\n      const direction = geodesicSegment.geometry.coordinates[0][0][0] > geodesicSegment.geometry.coordinates[1][0][0];\n      return [\n        ...geodesicSegment.geometry.coordinates[0].map(x => [x[0] + (direction ? 0 : 360), x[1]]),\n        ...geodesicSegment.geometry.coordinates[1].map(x => [x[0] + (direction ? 360 : 0), x[1]])\n      ];\n    } else {\n      return geodesicSegment.geometry.coordinates.map(x => [x[0] + (crossed ? 360 : 0), x[1]]);\n    }\n  }).flat();\n\n  return geodesicCoordinates.filter((coord, index) => index === geodesicCoordinates.length - 1 || !coordinatesEqual(coord, geodesicCoordinates[index + 1]));;\n};\n\nexport default createGeodesicLine;","function toRadians(value) {\n  return value / 180 * Math.PI;\n}\n\nfunction toDegrees(value) {\n  return value / Math.PI * 180;\n}\n\n// copied from https://stackoverflow.com/questions/57675924/calculated-midpoint-on-map-doesnt-overlap-with-geodesic-polyline\n// see also https://www.movable-type.co.uk/scripts/latlong.html\nfunction getGeodesicMidpoint(startCoord, endCoord) {\n  const deltaLongitude = toRadians(endCoord[0] - startCoord[0]);\n  const latitude1 = toRadians(startCoord[1]);\n  const latitude2 = toRadians(endCoord[1]);\n  const longitude1 = toRadians(startCoord[0]);\n\n  const Bx = Math.cos(latitude2) * Math.cos(deltaLongitude);\n  const By = Math.cos(latitude2) * Math.sin(deltaLongitude);\n\n  const latitude = Math.atan2(\n    Math.sin(latitude1) + Math.sin(latitude2),\n    Math.sqrt((Math.cos(latitude1) + Bx) * (Math.cos(latitude1) + Bx) + By * By)\n  );\n  const longitude = longitude1 + Math.atan2(By, Math.cos(latitude1) + Bx);\n\n  return [toDegrees(longitude), toDegrees(latitude)];\n};\n\nexport default getGeodesicMidpoint;","\"use strict\";\nfunction toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\nfunction toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\nfunction offset(c1, distance, bearing) {\n  var lat1 = toRadians(c1[1]);\n  var lon1 = toRadians(c1[0]);\n  var dByR = distance / 6378137; // distance divided by 6378137 (radius of the earth) wgs84\n  var lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n  );\n  var lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n\nfunction validateCenter(center) {\n  const validCenterLengths = [2, 3];\n  if (!Array.isArray(center) || !validCenterLengths.includes(center.length)) {\n    throw new Error(\"ERROR! Center has to be an array of length two or three\");\n  }\n  const [lng, lat] = center;\n  if (typeof lng !== \"number\" || typeof lat !== \"number\") {\n    throw new Error(\n      `ERROR! Longitude and Latitude has to be numbers but where ${typeof lng} and ${typeof lat}`\n    );\n  }\n  if (lng > 180 || lng < -180) {\n    throw new Error(\n      `ERROR! Longitude has to be between -180 and 180 but was ${lng}`\n    );\n  }\n\n  if (lat > 90 || lat < -90) {\n    throw new Error(\n      `ERROR! Latitude has to be between -90 and 90 but was ${lat}`\n    );\n  }\n}\n\nfunction validateRadius(radius) {\n  if (typeof radius !== \"number\") {\n    throw new Error(\n      `ERROR! Radius has to be a positive number but was: ${typeof radius}`\n    );\n  }\n\n  if (radius <= 0) {\n    throw new Error(\n      `ERROR! Radius has to be a positive number but was: ${radius}`\n    );\n  }\n}\n\nfunction validateNumberOfSegments(numberOfSegments) {\n  if (typeof numberOfSegments !== \"number\" && numberOfSegments !== undefined) {\n    throw new Error(\n      `ERROR! Number of segments has to be a number but was: ${typeof numberOfSegments}`\n    );\n  }\n\n  if (numberOfSegments < 3) {\n    throw new Error(\n      `ERROR! Number of segments has to be at least 3 but was: ${numberOfSegments}`\n    );\n  }\n}\n\nfunction validateInput({ center, radius, numberOfSegments }) {\n  validateCenter(center);\n  validateRadius(radius);\n  validateNumberOfSegments(numberOfSegments);\n}\n\nmodule.exports = function circleToPolygon(center, radius, numberOfSegments) {\n  var n = numberOfSegments ? numberOfSegments : 32;\n\n  // validateInput() throws error on invalid input and do nothing on valid input\n  validateInput({ center, radius, numberOfSegments });\n\n  var coordinates = [];\n  for (var i = 0; i < n; ++i) {\n    coordinates.push(offset(center, radius, (2 * Math.PI * -i) / n));\n  }\n  coordinates.push(coordinates[0]);\n\n  return {\n    type: \"Polygon\",\n    coordinates: [coordinates]\n  };\n};\n","import circleToPolygon from 'circle-to-polygon';\n\nfunction createGeodesicCircle(center, radius, steps) {\n  // circleToPolygon expects center in -180..180\n  const shiftedCenter = [((center[0] + 180) % 360 + 360) % 360 - 180, center[1]];\n  const shiftedPolygon = circleToPolygon(shiftedCenter, radius * 1000, steps);\n  const coordinates = shiftedPolygon.coordinates[0].map(x => [x[0] + (center[0] - shiftedCenter[0]), x[1]]);\n  return coordinates;\n}\n\nexport default createGeodesicCircle;","import * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport createVertex from '@mapbox/mapbox-gl-draw/src/lib/create_vertex';\nimport { isCircle, getCircleCenter, getCircleRadius } from './circle_geojson';\nimport createGeodesicLine from './create_geodesic_line';\nimport createGeodesicMidpoint from './create_geodesic_midpoint';\nimport createGeodesicCircle from './create_geodesic_circle';\n\nconst STEPS = 32;\n\nfunction minBy(array, func) {\n  const min = Math.min(...array.map(func));\n  return array.find(item => func(item) === min);\n}\n\nfunction maxBy(array, func) {\n  const max = Math.max(...array.map(func));\n  return array.find(item => func(item) === max);\n}\n\nfunction getCoordinate(coordinates, path) {\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const coordinate = ids.reduce((coordinates, id) => coordinates[id], coordinates);\n  return JSON.parse(JSON.stringify(coordinate));\n}\n\nfunction createGeodesicGeojson(geojson, options) {\n  options = { steps: STEPS, ...options };\n\n  const properties = geojson.properties;\n  const type = geojson.geometry.type;\n  const coordinates = geojson.geometry.coordinates;\n\n  const featureId = properties.parent || properties.id;\n  const featureGeojson = options.ctx.store.get(featureId).toGeoJSON();\n\n  if (type === Constants.geojsonTypes.POINT) {\n    if ((properties.meta === Constants.meta.VERTEX || properties.meta === Constants.meta.MIDPOINT) && featureGeojson && isCircle(featureGeojson)) {\n      return []; // hide circle points, they are displayed in processCircle instead\n    } else if (properties.meta === Constants.meta.MIDPOINT) {\n      return processMidpoint(); // calculate geodesic midpoint\n    } else {\n      return [geojson]; // pass point as is\n    }\n  } else if (type === Constants.geojsonTypes.LINE_STRING) {\n    return processLine(); // calculate geodesic line\n  } else if (type === Constants.geojsonTypes.POLYGON) {\n    if (featureGeojson && isCircle(featureGeojson)) {\n      return processCircle(); // calculate geodesic circle\n    } else {\n      return processPolygon(); // calculate geodesic polygon\n    }\n  } else /* istanbul ignore else */ if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {\n    return processMultiGeometry(); \n  }\n\n  function isSelectedPath(path) {\n    if (!options.selectedPaths) {\n      return false;\n    }\n    return options.selectedPaths.indexOf(path) !== -1;\n  }\n\n  function processMidpoint() {\n    const coordPath = properties.coord_path;\n\n    // subtract 1 from the last coord path id\n    const coordPathIds = coordPath.split('.').map(x => parseInt(x, 10));\n    const startCoordPath = coordPathIds.map((x, i) => x + (i === coordPathIds.length - 1 ? -1 : 0)).join('.');\n    const endCoordPath = coordPath;\n\n    const startCoord = getCoordinate(featureGeojson.geometry.coordinates, startCoordPath);\n    const endCoord = getCoordinate(featureGeojson.geometry.coordinates, endCoordPath);\n    const midCoord = createGeodesicMidpoint(startCoord, endCoord);\n\n    const geodesicGeojson = {\n      ...geojson,\n      properties: {\n        ...properties,\n        lng: midCoord[0],\n        lat: midCoord[1]\n      },\n      geometry: {\n        ...geojson.geometry,\n        coordinates: midCoord\n      },\n    };\n    return [geodesicGeojson];\n  }\n\n  function processLine() {\n    const geodesicCoordinates = createGeodesicLine(coordinates, options.steps);\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: geodesicCoordinates\n      }\n    };\n    return [geodesicGeojson];\n  }\n\n  function processPolygon() {\n    const geodesicCoordinates = coordinates.map((subCoordinates) => {\n      return createGeodesicLine(subCoordinates);\n    });\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: geodesicCoordinates\n      }\n    };\n    return [geodesicGeojson];\n  }\n\n  function processCircle() {\n    const center = getCircleCenter(featureGeojson);\n    const radius = getCircleRadius(featureGeojson);\n    const geodesicCoordinates = createGeodesicCircle(center, radius, options.steps * 4);\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: [geodesicCoordinates]\n      }\n    };\n\n    // circle handles\n    if (properties.active === Constants.activeStates.ACTIVE) {\n      const points = [\n        maxBy(geodesicCoordinates, x => x[0]), // north\n        minBy(geodesicCoordinates, x => x[0]), // south\n        maxBy(geodesicCoordinates, x => x[1]), // east\n        minBy(geodesicCoordinates, x => x[1])  // west\n      ];\n      const vertices = points.map((point, i) => {\n        return createVertex(properties.id, point, `0.${i}`, isSelectedPath(`0.${i}`));\n      })\n  \n      return [geodesicGeojson, ...vertices];\n    } else {\n      return [geodesicGeojson];\n    }\n  }\n\n  function processMultiGeometry() {\n    const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');\n    const geodesicFeatures = coordinates.map((subCoordinates) => {\n      const subFeature = {\n        type: Constants.geojsonTypes.FEATURE,\n        properties: properties,\n        geometry: {\n          type: subType,\n          coordinates: subCoordinates\n        }\n      };\n      return createGeodesicGeojson(subFeature, options);\n    }).flat();\n    const geodesicCoordinates = geodesicFeatures.map((subFeature) => {\n      return subFeature.geometry.coordinates;\n    });\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: geodesicCoordinates\n      }\n    };\n    return [geodesicGeojson];\n  }\n}\n\nexport default createGeodesicGeojson;","import * as Constants from '../constants';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import MapboxDraw from '@mapbox/mapbox-gl-draw';\nimport * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport createGeodesicFeature from '../utils/create_geodesic_geojson';\n\nconst DrawLineString = MapboxDraw.modes[Constants.modes.DRAW_LINE_STRING];\n\nconst DrawLineStringGeodesic = { ...DrawLineString };\n\nDrawLineStringGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicFeature(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  DrawLineString.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n};\n\nexport default DrawLineStringGeodesic;","import MapboxDraw from '@mapbox/mapbox-gl-draw';\nimport * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nconst DrawPolygon = MapboxDraw.modes[Constants.modes.DRAW_POLYGON];\n\nconst DrawPolygonGeodesic = { ...DrawPolygon };\n\nDrawPolygonGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n  \n  DrawPolygon.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n};\n\nexport default DrawPolygonGeodesic;","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","'use strict';\r\n\r\nmodule.exports = haversine;\r\n\r\nconst earth = {\r\n  MILE: 3959,\r\n  KM: 6371,\r\n  M: 6371000,\r\n  NMI: 3440\r\n};\r\n\r\nhaversine.EARTH = earth;\r\n\r\nfunction haversine(start, end, options) {\r\n  options = defaults(options);\r\n\r\n  const startLatitude = getRadians(start.latitude, options.isRadians);\r\n  const endLatitude = getRadians(end.latitude, options.isRadians);\r\n  const longitudeDelta = coordinateDifference(start.longitude, end.longitude, options.isRadians);\r\n\r\n  const c = Math.acos(Math.sin(startLatitude) * Math.sin(endLatitude) + Math.cos(startLatitude) * Math.cos(endLatitude) * Math.cos(longitudeDelta));\r\n\r\n  return options.radius * c;\r\n}\r\n\r\nfunction coordinateDifference(a, b, isRadians) {\r\n  const delta = b - a;\r\n  return getRadians(delta, isRadians);\r\n}\r\n\r\nfunction getRadians(input, isRadians) {\r\n  return isRadians ? input : (input * (Math.PI / 180));\r\n}\r\n\r\nfunction defaults(options) {\r\n  options = options || {};\r\n  options.radius = options.radius || earth.MILE;\r\n  options.isRadians = (typeof options.isRadians === 'boolean') ? options.isRadians : false;\r\n\r\n  return options;\r\n}\r\n","import haversine from 'haversine-js';\n\nfunction distance(start, end) {\n  return haversine(\n    { latitude: start[1], longitude: start[0] },\n    { latitude: end[1], longitude: end[0] },\n    { radius: haversine.EARTH.KM }\n  );\n}\n\nexport default distance;","const dragPan = {\n    enable(ctx) {\n        setTimeout(() => {\n            // First check we've got a map and some context.\n            if (!ctx.map || !ctx.map.dragPan || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n            // Now check initial state wasn't false (we leave it disabled if so)\n            if (!ctx._ctx.store.getInitialConfigValue('dragPan')) return;\n            ctx.map.dragPan.enable();\n        }, 0);\n    },\n    disable(ctx) {\n        setTimeout(() => {\n            if (!ctx.map || !ctx.map.doubleClickZoom) return;\n            // Always disable here, as it's necessary in some cases.\n            ctx.map.dragPan.disable();\n        }, 0);\n    },\n};\n\nexport default dragPan;","import * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport * as CommonSelectors from '@mapbox/mapbox-gl-draw/src/lib/common_selectors';\nimport doubleClickZoom from '@mapbox/mapbox-gl-draw/src/lib/double_click_zoom';\nimport * as ConstantsGeodesic from '../constants';\nimport { createCircle, getCircleCenter } from '../utils/circle_geojson';\nimport distance from '../utils/distance';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\nimport dragPan from '../utils/drag_pan';\n\nconst DrawCircleGeodesic = {};\n\nDrawCircleGeodesic.onSetup = function(opts) {\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  dragPan.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.setActionableState(); // default actionable state is false for all actions\n  return {};\n};\n\nDrawCircleGeodesic.onMouseDown = DrawCircleGeodesic.onTouchStart = function(state, e) {\n  const center = [e.lngLat.lng, e.lngLat.lat];\n  const circle = this.newFeature(createCircle(center, Number.EPSILON));\n  this.addFeature(circle);\n  state.circle = circle;\n};\n\nDrawCircleGeodesic.onDrag = DrawCircleGeodesic.onTouchMove = function(state, e) {\n  const point = [e.lngLat.lng, e.lngLat.lat];\n\n  if (state.circle) {\n    const geojson = state.circle.toGeoJSON();\n    const center = getCircleCenter(geojson);\n    const radius = distance(center, point);\n    state.circle.setProperty(ConstantsGeodesic.properties.CIRCLE_RADIUS, radius);\n    state.circle.changed();\n  }\n};\n\nDrawCircleGeodesic.onMouseUp = DrawCircleGeodesic.onTouchEnd = function(state, e) {\n  this.map.fire(Constants.events.CREATE, { features: [state.circle.toGeoJSON()] });\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.circle.id] });\n};\n\nDrawCircleGeodesic.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    if (state.circle) {\n      this.deleteFeature([state.circle.id], { silent: true });\n    }\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.circle.id] });\n  }\n};\n\nDrawCircleGeodesic.onStop = function() {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  dragPan.enable(this);\n  this.activateUIButton();\n}\n\nDrawCircleGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  if (state.circle) {\n    const isActivePolygon = geojson.properties.id === state.circle.id;\n    geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  }\n\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  displayGeodesic(geojson);\n};\n\nexport default DrawCircleGeodesic;","import * as Constants from '../constants';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","import MapboxDraw from '@mapbox/mapbox-gl-draw';\nimport * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nconst DrawPoint = MapboxDraw.modes[Constants.modes.DRAW_POINT];\n\nconst DrawPointGeodesic = { ...DrawPoint };\n\nDrawPointGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  DrawPoint.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n};\n\nexport default DrawPointGeodesic;","import MapboxDraw from '@mapbox/mapbox-gl-draw';\nimport * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nconst SimpleSelect = MapboxDraw.modes[Constants.modes.SIMPLE_SELECT];\n\nconst SimpleSelectGeodesic = { ...SimpleSelect };\n\nSimpleSelectGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  SimpleSelect.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n};\n\nexport default SimpleSelectGeodesic;","import MapboxDraw from '@mapbox/mapbox-gl-draw';\nimport * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport * as ConstantsGeodesic from '../constants';\nimport { isCircle, getCircleCenter } from '../utils/circle_geojson';\nimport distance from '../utils/distance';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nconst DirectSelect = MapboxDraw.modes[Constants.modes.DIRECT_SELECT];\n\nconst DirectSelectGeodesic = { ...DirectSelect };\n\nDirectSelectGeodesic.dragVertex = function(state, e, delta) {\n  const point = [e.lngLat.lng, e.lngLat.lat];\n  const geojson = state.feature.toGeoJSON();\n\n  if (isCircle(geojson)) {\n    const center = getCircleCenter(geojson);\n    const radius = distance(center, point);\n    state.feature.setProperty(ConstantsGeodesic.properties.CIRCLE_RADIUS, radius);\n    state.feature.changed();\n  } else {\n    DirectSelect.dragVertex.call(this, state, e, delta);\n  }\n};\n\nDirectSelectGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx, selectedPaths: state.selectedCoordPaths });\n    geodesicGeojson.forEach(display);\n  };\n  \n  DirectSelect.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n};\n\nexport default DirectSelectGeodesic;","import createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\n// copied from https://github.com/mapbox/mapbox-gl-draw-static-mode\nconst StaticGeodesic = {};\n\nStaticGeodesic.onSetup = function() {\n  this.setActionableState(); // default actionable state is false for all actions\n  return {};\n};\n\nStaticGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  displayGeodesic(geojson);\n};\n\nexport default StaticGeodesic;","\nimport * as Constants from '@mapbox/mapbox-gl-draw/src/constants';\nimport * as ConstantsGeodesic from '../constants';\nimport DrawLineStringGeodesic from './draw_line_string_geodesic';\nimport DrawPolygonGeodesic from './draw_polygon_geodesic';\nimport DrawCircleGeodesic from './draw_circle_geodesic';\nimport DrawPointGeodesic from './draw_point_geodesic';\nimport SimpleSelectGeodesic from './simple_select_geodesic';\nimport DirectSelectGeodesic from './direct_select_geodesic';\nimport StaticGeodesic from './static_geodesic';\n\nexport const modes = {\n    [Constants.modes.DRAW_LINE_STRING]: DrawLineStringGeodesic,\n    [Constants.modes.DRAW_POLYGON]: DrawPolygonGeodesic,\n    [ConstantsGeodesic.modes.DRAW_CIRCLE]: DrawCircleGeodesic,\n    [Constants.modes.DRAW_POINT]: DrawPointGeodesic,\n    [Constants.modes.SIMPLE_SELECT]: SimpleSelectGeodesic,\n    [Constants.modes.DIRECT_SELECT]: DirectSelectGeodesic,\n    [Constants.modes.STATIC]: StaticGeodesic,\n};"],"names":["cursors","geojsonTypes","modes","events","meta","activeStates","properties","obj","key","value","Object","defineProperty","enumerable","configurable","writable","hat","module","bits","base","undefined","digits","Math","log","pow","i","Infinity","rem","floor","res","random","toString","b","parsed","parseInt","rack","expandBy","fn","data","iters","Error","id","hasOwnProperty","call","hats","get","set","createCircle","center","radius","type","Constants","ConstantsGeodesic","geometry","coordinates","isCircle","geojson","getCircleCenter","getCircleRadius","D2R","PI","R2D","Coord","lon","lat","x","y","prototype","view","String","this","slice","antipode","anti_lat","anti_lon","LineString","coords","length","move_to","coord","push","Arc","geometries","json","multiline","wkt","wkt_string","collect","c","forEach","substring","GreatCircle","start","end","w","h","z","sin","cos","g","asin","sqrt","isNaN","interpolate","f","A","B","atan2","npoints","options","first_pass","delta","step","pair","bHasBigDiff","dfMaxSmallDiffLong","dfDateLineOffset","offset","dfLeftBorderX","dfRightBorderX","dfDiffSpace","j","dfPrevX","dfX","dfDiffLong","abs","poMulti","poNewLS","k","dfX0","parseFloat","dfX1","dfY1","dfX2","dfY2","tmpX","tmpY","dfRatio","dfY","poNewLS0","l","arc","m","line","points","j0","coordinatesEqual","createGeodesicLine","steps","array","geodesicSegments","map","index","filter","segment","crossed","geodesicCoordinates","geodesicSegment","direction","flat","toRadians","toDegrees","angleInDegrees","angleInRadians","c1","distance","bearing","lat1","lon1","dByR","validateInput","numberOfSegments","Array","isArray","includes","lng","validateCenter","validateRadius","validateNumberOfSegments","createGeodesicCircle","shiftedCenter","shiftedPolygon","n","circleToPolygon","minBy","func","min","find","item","maxBy","max","getCoordinate","path","coordinate","split","reduce","JSON","parse","stringify","createGeodesicGeojson","featureId","parent","featureGeojson","ctx","store","toGeoJSON","coordPath","coord_path","coordPathIds","startCoordPath","join","endCoordPath","startCoord","endCoord","midCoord","deltaLongitude","latitude1","latitude2","longitude1","Bx","By","latitude","createGeodesicMidpoint","processMidpoint","processLine","geodesicGeojson","active","vertices","point","parentId","selected","createVertex","selectedPaths","indexOf","isSelectedPath","processCircle","subCoordinates","processPolygon","subType","replace","subFeature","processMultiGeometry","DrawLineString","MapboxDraw","DrawLineStringGeodesic","toDisplayFeatures","state","display","createGeodesicFeature","_ctx","DrawPolygon","DrawPolygonGeodesic","enable","setTimeout","doubleClickZoom","getInitialConfigValue","disable","haversine","earth","MILE","KM","M","NMI","isRadians","defaults","startLatitude","getRadians","endLatitude","longitudeDelta","a","longitude","acos","input","EARTH","dragPan","DrawCircleGeodesic","onSetup","opts","clearSelectedFeatures","updateUIClasses","mouse","setActionableState","onMouseDown","onTouchStart","e","lngLat","circle","newFeature","Number","EPSILON","addFeature","onDrag","onTouchMove","setProperty","changed","onMouseUp","onTouchEnd","fire","features","changeMode","featureIds","onKeyUp","keyCode","CommonSelectors","deleteFeature","silent","onStop","activateUIButton","isActivePolygon","displayGeodesic","DrawPoint","DrawPointGeodesic","SimpleSelect","SimpleSelectGeodesic","DirectSelect","DirectSelectGeodesic","dragVertex","feature","selectedCoordPaths","StaticGeodesic"],"mappings":"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"}